<!DOCTYPE html>
<html>

<head>
<!-- JavaScript will load the header content here -->
<link rel="icon" href="\images\generic\favicon.ico" type="image/x-icon">
</head>

<body>
<script>
    fetch('https://kylerandomnes.github.io/header/header.html')
    .then(response => response.text())
        .then(data => {
            document.querySelector('head').innerHTML += data;
        })
        .catch(error => console.error('Error loading header:', error));
</script>

<!-- Calling Function to render projectData -->
<script src="/functions/projects.js"></script>

<script>
    const projects = [
    {
        title: "Bounce the ball",
        description: `This is project was started by my friend he called me soon into his project 
        where he was learning the matter.js Engine, which allowed for some good physics. He wanted to 
        create an online game, however was unsure of how to do certain tasks. He called me so we could 
        split the tasks into 2. If you click this it will take you to my collabrators github`,
        video: "/images/selfStudy/BallBouncer/ballBounce.mp4",
        nonClickable: false,
        link: "https://github.com/BlakeJacobi"
    },
    {
        subtitle: "Version 0.1",
        description: `This is what I recieved as the basic project, upon taking a look my partner 
        had placed everything in one class, which worked very well for the smaller scale project. 
        I realized this would not do for as the project grew and decided to make my first priority to 
        divide the functions into multiple classes. Jan 20 2025`,
        images: ["/images/selfStudy/BallBouncer/FirstCodeStruct.png"],
        nonClickable: true,
    },
    {
        subtitle: "Version 0.2 ~option A",
        description: `<p>The start of this project was delayed, I knew what I would need to do however I 
        was preoccupied with creating other projects. After creating the changes from the previous version 
        I showed my teammate and they approved of the changes finding them to make the code base a lot 
        easier to work with. It also meant that further iterations would be less complicated and finding 
        bugs would become a lot simplier.</p>
        
        <h2>Further details:</h2>
        <p>To start the first part I changed was removing controls from the code base and creating a folder 
        where controls could be placed, splitting it into 2 classes of movement and one for input. This 
        would mean that if we added more inputs they would only go into one class and then changing how 
        movement worked for later could be done with minimal issues.</p>
            
        <p>The next step I took was removing obstacle spawning and movement from the main codebase into 
        it's own folder and into 2 classes. This did however result in a bug where after reset obstacles 
        would immeditly spawn instead of taking the time they took before to spawn. This is a bug I'd have 
        to solve later, however at the time I placed it on a lower priority than getting the code fully 
        seperated.</p>
        
        <p>The final step was to remove game manager from the system into their own folder and into 
        3 classes, these classes would be score, time and gameOver. The score was done first and I 
        figured out quickly that I'd need to remove time for this to be effective as many objects in score 
        called time. Once I got time sorted as well, both functioned and then I got to work with the game 
        restart and game over. With all of these working, I had made the code base a lot easier to function 
        and also decreased the reading complexity of the code</p>
        
        <p>I then returned to the bug, which required me to resort how the spawning was working, where I 
        found the bug was because I failed to reinitalize the obstacle array correctly and remove all 
        the obstacles that were there before, thus placing you where you were before just having every 
        obstacle move places. This also then fixed the second issue that sometimes occured where 
        obstacles would stop moving after all original obstacles were destroyed. Once everything 
        was sorted the game was in the same state as before I started the project, so players would 
        not experince the difference but for coding in future these changes would make the game feel a 
        lot more clean and readable.</p> March 27 2025`,
        images: ["/images/selfStudy/BallBouncer/SecondCodeStruct.png"],
        nonClickable: true,
    },
    {
        subtitle: "Version 0.2 ~ option B",
        description: `<p>This version started a bit later than planned, as I was occupied with other 
        projects. But once I returned to it, I focused on restructuring the codebase to make future 
        development easier. After showing the changes to my teammate, they found the new structure 
        much easier to work with—which made debugging and iterating smoother.</p>
        
        Key Changes:
        <ul><li><strong>Input Refactor:</strong>Moved control logic into a separate folder with two 
        movement classes and one input class. This modular setup means future inputs can be 
        added in one place with minimal disruption.</li> <li><strong>Obstacle Logic:</strong> 
        Extracted obstacle spawning and movement into their own folder and split into two classes. 
        Initially caused a bug where obstacles spawned too quickly after reset—this was noted for later.
        </li> <li><strong>Game Manager Breakdown:</strong> Separated game management into three classes: 
        <code>Score</code>, <code>Time</code>, and <code>GameOver</code>. Time had to be decoupled before 
        score would function properly, due to dependencies.</li> </ul>
        
        Bug Fixes:
        <p> After finishing the restructure, I revisited the obstacle spawn bug. Turns out I wasn’t 
        reinitializing the obstacle array correctly. Fixing that solved both the instant-spawn issue 
        and another bug where obstacles sometimes stopped moving after reset. </p> <p> By the end of 
        this version, the game looked and played the same to users—but under the hood, it was far 
        cleaner and easier to maintain. These changes will make future development much smoother. </p> March 27 2025`,
        images: ["/images/selfStudy/BallBouncer/SecondCodeStruct.png"],
        nonClickable: true,
    },
    {
        subtitle: "Version 0.2 ~ option C",
        description: `<p>The start of this project was delayed. I knew what I needed to do, but I was 
        preoccupied with creating other projects first. After making the changes from the previous version, 
        I showed them to my teammate — they approved and found the codebase much easier to work with. This 
        meant future iterations would be less complicated, and finding bugs would become a lot simpler too.</p>

        <h2>Further Details:</h2>

        <p><strong>First step:</strong><br>
        I started by removing the controls from the main codebase and creating a new folder specifically 
        for them. I split the controls into two movement classes and one input class. This setup meant that 
        if we ever added new inputs, they would only need to go into one place — and changing how movement 
        worked later would cause minimal issues.</p>

        <p><strong>Second step:</strong><br>
        I removed obstacle spawning and movement from the main code and placed them into their own folder, 
        splitting them into two separate classes. This did cause a bug: after resetting the game, obstacles 
        would immediately spawn instead of waiting the proper amount of time. At the time, I decided to 
        place this bug on a lower priority and focus first on finishing the code separation.</p>

        <p><strong>Third step:</strong><br>
        Finally, I removed the game manager from the main system and split it into three classes: 
        <code>Score</code>, <code>Time</code>, and <code>GameOver</code>.<br>
        - I tackled the <code>Score</code> class first, but quickly realized I had to refactor 
        <code>Time</code> too — because many parts of the scoring system were dependent on it.<br>
        - Once <code>Time</code> was properly separated, both <code>Score</code> and <code>Time</code> functioned correctly.<br>
        - After that, I moved on to restructuring the game restart and game over logic.</p>

        <p>With all these parts working, the codebase became way easier to work with, and I noticeably 
        reduced the reading complexity.</p>

        <h2>Bug Revisit:</h2>

        <p>After the core restructure, I returned to the earlier obstacle spawning bug. 
        The issue was that I hadn't properly reinitialized the obstacle array after a reset — I wasn’t 
        removing the old obstacles. Because of that, the game was basically placing you back into a world 
        where all the obstacles had simply moved positions.</p>

        <p>Fixing this not only solved the instant-spawn issue but also cleared up a second bug where 
        obstacles would sometimes stop moving entirely after a reset.</p>

        <p>By the end of this version, the game <em>looked and played</em> the same for users — but under 
        the hood, it was way cleaner, more maintainable, and better prepared for future updates. 
        Even though players wouldn’t notice the changes, for development and bug-fixing, it made a huge 
        difference.</p> March 27 2025`,
        images: ["/images/selfStudy/BallBouncer/SecondCodeStruct.png"],
        nonClickable: true,
    }


];
</script>

<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderProjects(projects);
    });
</script>

<div class="scroll">

<!-- Links to other sites -->
<div id="navbar"></div>
<script>
    // Load the external navigation bar
    fetch('/functions/navbar.html')
        .then(response => response.text())
        .then(data => {
            document.getElementById('navbar').innerHTML = data;

            // Check if there’s a history to go back to AFTER loading the navbar
            if (window.history.length > 1) {
                // Show the Back button
                document.getElementById('backButton').style.display = 'inline';
            }
        })
        .catch(error => console.error('Error loading navigation bar:', error));
</script>
<!-- Load the external hotkeys script from the functions folder -->
<script src="functions\hotkeys.js"></script>

</body>

</html>